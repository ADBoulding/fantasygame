<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Default parameters for characters
// It's safe to edit these (even encouraged, depending on your game)

default_textspeed = 1;
default_color = c_black;
default_font = fnt_messagebox;
default_alpha = 1;



// Information about the size of the messagebox and the
// height of a line. Is used for defining newlines...

maxwidth = room_width - 10;
lineheight = 16;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Intern variables, please do not change me :(


// Variable to keep the text in
text = "";

// Variables for the pointer that says which to draw until a
// certain set of characters
pointer = 0;
oldpointer = pointer;
textspeed = 1;
rest = 0;

//Variables about the current state
state = 0;
//0 = inactive
//1 = drawing on screen
//2 = completed drawing on screen
//3 = quiting

//Variables that keep track of the characters' color, position, font...
//charlist - array()
chars = 0;

val_font = 0;
val_color = 1;
val_speed = 2;
val_alpha = 3;
val_x = 4;
val_y = 5;
val_char = 6;

//Array for actions to execute when pointer changes
//actionlist - array()
actions = 0;

val_start = 0;
val_type = 1;
val_value = 2;

//textspeed
textspeed = default_textspeed;
skipat = -1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Increase the position of the text, and do actions.

// When currently "active"
if (state == 1)
{
    if (chars == 0) {
        state = 2;
    }
    
    do {
        textspeed = charlist[median(0, pointer, chars-1), val_speed];
        
        if (textspeed == -1) {
            pointer += 1;
        } else {
            rest += textspeed;
            
            repeat (floor(rest))
            {
                rest -= 1;
                pointer += 1;
            }
        }
        
        // NOTE: Check for actions
        // The implementation is dependent for each game
        for (i = 0; i &lt; actions; i++)
        {
            if (pointer == actionlist[i,val_start])
            {
                var arg;
                arg = actionlist[i,val_value];
                
                switch (actionlist[i,val_type])
                {
                
                    case "sound":
                        // TODO: Do something with a sound effect
                    break;
                    
                    case "music":
                        // TODO: Do something with a music
                    break;
                    
                    case "sprite":
                        // TODO: Do something with a sprite
                    break;
                    
                    case "background":
                        // TODO: Do something with a background
                        background_index[0] = arg;
                        
                    break;
                
                }
            }
        }
        
        if (pointer &gt;= chars)
        {
            textspeed = 0; // Reset textspeed here, so we can leave the loop
            rest = 0;
            pointer = chars;
            state = 2;
        }
        
    } until (textspeed != -1)
    
    if ( (skipat != -1) and (skipat &lt;= pointer)  ) {
        state = 3;
    }
}

// When done, wait for space to go to next one
if (state == 2)
{
    if (keyboard_check(vk_space))
    {
        state = 3;
    }
}

// Destroy this instance when completed
if (state == 3) {
    instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Parse the input given by the user

/*

Parsing the input happens in two phases.

- In the first phase, the input is parsed by looking for all opening and closing tags, and setting the properties of each character.
- In the second phase, the characters are given a position depending on their character width, or total word width.

*/

// Set values
var resttext;
resttext = text;
state = 1;

// Current properties of a character
var cur_font,cur_color,cur_speed;
cur_font = default_font;
cur_color = default_color;
cur_speed = default_textspeed;
cur_alpha = default_alpha;

// Stacks with the old values, filled in opening tags, emptied in closing tags
var stack_font, stack_color, stack_speed, stack_alpha;
stack_font = ds_stack_create();
stack_color = ds_stack_create();
stack_speed = ds_stack_create();
stack_alpha = ds_stack_create();

/*
    First phase
*/

// Parse the string
while (resttext != "")
{
    var c;
    c = string_copy(resttext,1,1);
    resttext = string_copy(resttext,2,string_length(resttext)-1);
    
    if (c == "[")
    {

        // Find position of closing tag and disable outputting the character
        var p = string_pos("]",resttext);
        c = "";
        
        // Only do something when closing is found
        if (p != 0)
        {
            p -= 1;
            
            var inside;
            inside = string_copy(resttext, 1, p);
            resttext = string_copy(resttext, p+2, string_length(resttext)-p-1);
            
            // Check if there is a paramter for this tag
            
            var p2;
            p2 = string_pos("=",inside);
            
            if (p2 == 0)
            {
                // No parameter
                switch (inside)
                {
                
                    case "instant":
                    ds_stack_push(stack_speed, cur_speed);
                        cur_speed = -1;
                        break;
                        
                    case "skip":
                    case "next":
                        skipat = chars;
                        c = " ";
                        break;
                    
                    case "/color":
                        if (ds_stack_empty(stack_color)) {
                            cur_color = default_color;
                        } else {
                            cur_color = ds_stack_pop(stack_color);
                        }
                        break;
                    
                    case "/font":
                        if (ds_stack_empty(stack_font)) {
                            cur_font = default_font;
                        } else {
                            cur_font = ds_stack_pop(stack_font);
                        }
                        break;
                        
                    case "/instant":
                    case "/speed":
                        if (ds_stack_empty(stack_speed)) {
                            cur_speed = default_textspeed;
                        } else {
                            cur_speed = ds_stack_pop(stack_speed);
                        }
                        break;
                        
                    case "/alpha":
                        if (ds_stack_empty(stack_alpha)) {
                            cur_alpha = default_alpha;
                        } else {
                            cur_alpha = ds_stack_pop(stack_alpha);
                        }
                        break;
                        
                    // Add your own tags with no parameter here...
                        
                }
            
            }
            else
            {
            
                // There is one parameter
                var a,b;
                a = string_copy(inside,1,p2-1);
                b = string_copy(inside,p2+1,string_length(inside)-p2);
                
                switch (a)
                {
                    case "color":
                        ds_stack_push(stack_color, cur_color);
                        cur_color = string_to_color(b);
                        break;
                    
                    case "font":
                        ds_stack_push(stack_font, cur_font);
                        cur_font = asset_get_index(b);
                        break;
                    
                    case "speed":
                        ds_stack_push(stack_speed, cur_speed);
                        cur_speed = real(b);
                        break;
                        
                    case "alpha":
                        ds_stack_push(stack_alpha, cur_alpha);
                        cur_alpha = real(b);
                        break;
                    
                    case "sound":
                    actionlist[actions,val_start] = chars+1;
                    actionlist[actions,val_type] = "sound";
                    actionlist[actions,val_value] = asset_get_index(b);
                    actions += 1;
                    break;
                    
                    case "music":
                    actionlist[actions,val_start] = chars+1;
                    actionlist[actions,val_type] = "music";
                    actionlist[actions,val_value] = asset_get_index(b);
                    actions += 1;
                    break;
                    
                    case "sprite":
                    actionlist[actions,val_start] = chars+1;
                    actionlist[actions,val_type] = "sprite";
                    actionlist[actions,val_value] = asset_get_index(b);
                    actions += 1;
                    break;
                    
                    case "background":
                    actionlist[actions,val_start] = chars+1;
                    actionlist[actions,val_type] = "background";
                    actionlist[actions,val_value] = asset_get_index(b);
                    actions += 1;
                    break;
                    
                    // NOTE: Add your own tags with one parameter here
                    // NOTE: Use actionlist to save specific actions
                }
            
            }
        }
    }

    // When the character is not "empty", add it to the list of characters.    
    if (c != "") {
        charlist[chars,val_font] = cur_font;
        charlist[chars,val_color] = cur_color;
        charlist[chars,val_speed] = cur_speed; //Exception: -1 = instant
        charlist[chars,val_alpha] = cur_alpha;
        charlist[chars,val_x] = 0; //x
        charlist[chars,val_y] = 0; //y
        charlist[chars,val_char] = c; //Exception: skip =&gt; instance_destroy()
        chars += 1;
    }

}

// Remove data structures (avoid memory leaks)
ds_stack_destroy(stack_alpha);
ds_stack_destroy(stack_speed);
ds_stack_destroy(stack_color);
ds_stack_destroy(stack_font);


/*
Second phase
*/

// Define the position of each character
var lasti,wordwidth,linewidth;
lasti = 0;
wordwidth = 0;
linewidth = 0;

var xx,yy;
xx = 0;
yy = 0;

for (i = 0; i &lt; chars; i++)
{

    var c;
    c = charlist[i,val_char];
    
   
    if ( (c == " ") or (c == "#") )
    {
        // When word was too long, set it to new line
        
        if (wordwidth+linewidth &gt;= maxwidth)
        {
            xx = 0;
            yy += lineheight;
            linewidth = 0;
        }
        
        //Some characters have special properties
        // \ = not visible
        
        for (i2 = lasti; i2 &lt; i; i2++)
        {
            if (charlist[i2,val_char] == "\")
            {
                charlist[i2,val_char] = "";
            }
            else
            {
                draw_set_font(charlist[i2,val_font]);
                
                charlist[i2,val_x] = xx;
                charlist[i2,val_y] = yy;
                
                xx += string_width(charlist[i2,val_char]);
            }
            
        }
        
        // Handle width of space
        var sp;
        sp = string_width(" ");
        xx += sp;
        wordwidth += sp;
        
        // If new line, go to new line
        if (c == "#")
        {
            xx = 0;
            yy += lineheight;
            linewidth = 0;
        }
        
        lasti = i+1;
        
        linewidth += wordwidth;
        wordwidth = 0;
        
    }
    else
    {
        // Add width of character to width of current word
        draw_set_font(charlist[i,val_font]);
        wordwidth += string_width(c);
    }

}

// Finish unparsed part (last word, which doesn't have a newline)
if (lasti != chars)
{
    if (wordwidth+linewidth &gt;= maxwidth)
    {
        xx = 0;
        yy += lineheight;
        linewidth = 0;
    }
    
    //Some characters have special properties
    // \ = not visible
    for (i2 = lasti; i2 &lt; i; i2++)
    {
        if (charlist[i2,val_char] == "\")
        {
            charlist[i2,val_char] = "";
        }
        else
        {
            draw_set_font(charlist[i2,val_font]);
        
            charlist[i2,val_x] = xx;
            charlist[i2,val_y] = yy;
            
            xx += string_width(charlist[i2,val_char]);
        }
        
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw characters

// NOTE: Alter this, depending on your game

if (state == 0) {
    exit;
}

var offsetx,offsety;
offsetx = 5;
offsety = 5;

for (i = 0; i &lt; min(pointer,chars); i++) {
    draw_set_font(charlist[i,val_font]);
    draw_set_color(charlist[i,val_color]);
    
    draw_text(offsetx+charlist[i,val_x],offsety+charlist[i,val_y],charlist[i,val_char]);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
